<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2018-03-16 Fri 12:51 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mean/dispersion estimation</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Abhishek Sarkar">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<style type="text/css">body {width: 60em; margin:auto} pre.src {overflow:auto}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Mean/dispersion estimation</h1>

<div id="outline-container-orgde98ea2" class="outline-2">
<h2 id="orgde98ea2">Introduction</h2>
<div class="outline-text-2" id="text-orgde98ea2">
<p>
We take a modular approach to call QTLs:
</p>

<ol class="org-ol">
<li>Estimate a mean and a dispersion for each individual</li>
<li>Treat the mean/dispersion as continuous phenotypes and perform QTL mapping</li>
</ol>

<p>
Here, we solve (1).
</p>

<ol class="org-ol">
<li><a href="#org614c5c8">We implement GPU-based ML estimation</a></li>
<li><a href="#org6ace9b3">We implement CPU-based ML estimation</a></li>
</ol>
</div>
</div>

<div id="outline-container-org83e68c4" class="outline-2">
<h2 id="org83e68c4">Model specification</h2>
<div class="outline-text-2" id="text-org83e68c4">
<p>
Let \(r_{ijk}\) denote the number of molecules for individual \(i\), cell
\(j\), gene \(k\). Let \(R_{ij}\) denote a size factor for each cell. As a
first pass, define \(R_{ij} = \sum_k r_{ijk}\).
</p>

<p>
Following Hilbe 2012, we derive the negative binomial as a Poisson-Gamma
mixture:
</p>

<p>
\[ r_{ijk} \sim \text{Pois}(R_{ij} \mu_{ik} u_{ijk}) \]
</p>

<p>
\[ u_{ijk} \sim \text{Gamma}(\phi_{ik}^{-1}, \phi_{ik}^{-1}) \]
</p>

<p>
Here, \(\mu_{ik}u_{ijk}\) denotes relative expression
(<a href="https://arxiv.org/abs/1104.3889">Pachter 2011</a>). Marginalizing out \(u\)
yields the negative binomial distribution, with log likelihood:
</p>

<p>
\[ \ln p(r_{ijk} \mid R_{ij}, \mu_{ik}, \phi_{ik}) = r_{ijk} \ln\left(\frac{R_{ij}\mu_{ik}\phi_{ik}}{1 + R_{ij}\mu_{ik}\phi_{ik}}\right) - \phi_{ik}^{-1} \ln(1 + R_{ij}\mu_{ik}\phi_{ik}) + \ln \Gamma(r_{ijk} + \phi_{ik}^{-1}) - \ln \Gamma(r_{ijk} + 1) - \ln \Gamma(\phi^{-1}) \]
</p>

<p>
We have multiple data points (30-200 cells) per mean/dispersion parameter, so
simply minimizing the negative log likelihood should give reasonable
estimates.
</p>

<p>
We additionally account for zero-inflation, by letting \(\pi_{ik}\) denote
the probability of observing an excess zero (not arising from the
negative-binomial).
</p>

<p>
Then, the log-likelihood of the data is:
</p>

<p>
\[ \ln p(r_{ijk} \mid \cdot) = \ln(\pi_{ik} + (1 -  \pi_{ik}) p(r_{ijk}
    \mid R_{ij}, \mu_{ik}, \phi_{ik}))\ \text{if}\ r_{ijk} = 0 \]
\[ \ln p(r_{ijk} \mid \cdot) = \ln(1 - \pi_{ik}) + \ln p(r_{ijk} \mid
    R_{ij}, \mu_{ik}, \phi_{ik})\ \text{otherwise} \]
</p>
</div>
</div>

<div id="outline-container-org614c5c8" class="outline-2">
<h2 id="org614c5c8">Tensorflow implementation</h2>
<div class="outline-text-2" id="text-org614c5c8">
<p>
We optimize all of the parameters together, using one-hot encoding to map
parameters to data points. This makes inference more amenable to running on
the GPU.
</p>

<p>
Use <code>tensorflow</code> to automatically differentiate the negative log likelihood and
perform gradient descent.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgc619ce3"><span class="org-keyword">def</span> <span class="org-function-name">sigmoid</span>(x):
  <span class="org-doc">"""Numerically safe sigmoid"""</span>
  <span class="org-keyword">return</span> tf.clip_by_value(tf.sigmoid(x), -13, 13)

<span class="org-keyword">def</span> <span class="org-function-name">log</span>(x):
  <span class="org-doc">"""Numerically safe log"""</span>
  <span class="org-keyword">return</span> tf.log(x + 1e-8)

<span class="org-keyword">def</span> <span class="org-function-name">nb_llik</span>(x, mean, inv_disp):
  <span class="org-doc">"""Log likelihood of x distributed as NB</span>

<span class="org-doc">  See Hilbe 2012, eq. 8.10</span>

<span class="org-doc">  mean - mean (&gt; 0)</span>
<span class="org-doc">  inv_disp - inverse dispersion (&gt; 0)</span>

<span class="org-doc">  """</span>
  <span class="org-keyword">return</span> (x * log(mean / inv_disp) -
          x * log(1 + mean / inv_disp) -
          inv_disp * log(1 + mean / inv_disp) +
          tf.lgamma(x + inv_disp) -
          tf.lgamma(inv_disp) -
          tf.lgamma(x + 1))

<span class="org-keyword">def</span> <span class="org-function-name">zinb_llik</span>(x, mean, inv_disp, logodds, eps=1e-8):
  <span class="org-doc">"""Log likelihood of x distributed as ZINB</span>

<span class="org-doc">  See Hilbe 2012, eq. 11.12, 11.13</span>

<span class="org-doc">  mean - mean (&gt; 0)</span>
<span class="org-doc">  inv_disp - inverse dispersion (&gt; 0)</span>
<span class="org-doc">  logodds - dropout log odds</span>

<span class="org-doc">  """</span>
  <span class="org-variable-name">case_zero</span> = log(sigmoid(-logodds) + sigmoid(logodds) * tf.exp(nb_llik(x, mean, inv_disp)))
  <span class="org-variable-name">case_non_zero</span> = -tf.nn.softplus(logodds) + nb_llik(x, mean, inv_disp)
  <span class="org-keyword">return</span> tf.where(tf.less(x, 1e-8), case_zero, case_non_zero)

<span class="org-keyword">def</span> <span class="org-function-name">fit</span>(umi, onehot, size_factor, gene_dropout=<span class="org-constant">False</span>, ind_dropout=<span class="org-constant">False</span>, learning_rate=1e-2, max_epochs=1000):
  <span class="org-doc">"""Return estimated log mean and log dispersion. </span>

<span class="org-doc">  If fitting a zero-inflated model, additionally return dropout log odds.</span>

<span class="org-doc">  umi - count matrix (n x p; float32)</span>
<span class="org-doc">  onehot - mapping of individuals to cells (m x n; float32)</span>
<span class="org-doc">  size_factor - size factor vector (n x 1; float32)</span>
<span class="org-doc">  gene_dropout - fit one dropout parameter per gene</span>
<span class="org-doc">  ind_dropout - fit one dropout parameter per individual</span>
<span class="org-doc">  init_log_mean - initial value for estimated log mean (m x p; float32)</span>
<span class="org-doc">  init_log_disp - initial value for estimated log dispersion (m x p; float32)</span>

<span class="org-doc">  If ind_dropout is True, gene_dropout must be True, otherwise raises</span>
<span class="org-doc">  ArgumentError.</span>

<span class="org-doc">  Returns:</span>

<span class="org-doc">  log_mean - log mean parameter (m x p)</span>
<span class="org-doc">  log_disp - log dispersion parameter (m x p)</span>
<span class="org-doc">  dropout - dropout log odds (1 x p if gene_dropout, n x p if ind_dropout)</span>

<span class="org-doc">  """</span>
  <span class="org-variable-name">n</span>, <span class="org-variable-name">p</span> = umi.shape
  <span class="org-variable-name">_</span>, <span class="org-variable-name">m</span> = onehot.shape

  <span class="org-variable-name">params</span> = <span class="org-builtin">locals</span>()
  <span class="org-variable-name">graph</span> = tf.Graph()
  <span class="org-keyword">with</span> graph.as_default(), graph.device(<span class="org-string">'/gpu:*'</span>):
    <span class="org-variable-name">size_factor</span> = tf.Variable(size_factor, trainable=<span class="org-constant">False</span>)
    <span class="org-variable-name">umi</span> = tf.Variable(umi, trainable=<span class="org-constant">False</span>)
    <span class="org-variable-name">onehot</span> = tf.Variable(onehot, trainable=<span class="org-constant">False</span>)

    <span class="org-variable-name">mean</span> = tf.exp(tf.Variable(tf.zeros([m, p])))
    <span class="org-variable-name">inv_disp</span> = tf.exp(tf.Variable(tf.zeros([m, p])))

    <span class="org-keyword">if</span> gene_dropout:
      <span class="org-keyword">if</span> ind_dropout:
        <span class="org-variable-name">dropout_params</span> = tf.Variable(tf.zeros([m, p]))
        <span class="org-variable-name">dropout</span> = tf.matmul(onehot, dropout_params)
      <span class="org-keyword">else</span>:
        <span class="org-variable-name">dropout_params</span> = tf.Variable(tf.zeros([1, p]))
        <span class="org-variable-name">dropout</span> = dropout_params
      <span class="org-variable-name">llik</span> = tf.reduce_mean(
        zinb_llik(umi, size_factor * tf.matmul(onehot, mean),
                  tf.matmul(onehot, inv_disp), dropout))
    <span class="org-keyword">elif</span> ind_dropout:
      <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">'Cannot specify individual-specific dropout without gene-specific dropout'</span>)
    <span class="org-keyword">else</span>:
      <span class="org-variable-name">llik</span> = tf.reduce_mean(
        nb_llik(umi, size_factor * tf.matmul(onehot, mean),
                tf.matmul(onehot, inv_disp)))

    <span class="org-variable-name">train</span> = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(-llik)
    <span class="org-variable-name">opt</span> = [tf.log(mean), -tf.log(inv_disp)]
    <span class="org-keyword">if</span> gene_dropout:
      opt.append(dropout_params)
    <span class="org-variable-name">curr</span> = <span class="org-builtin">float</span>(<span class="org-string">'-inf'</span>)
    <span class="org-keyword">with</span> tf.Session() <span class="org-keyword">as</span> sess:
      sess.run(tf.global_variables_initializer())
      <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(max_epochs):
        <span class="org-variable-name">_</span>, <span class="org-variable-name">update</span> = sess.run([train, llik])
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> np.isfinite(update):
          <span class="org-keyword">raise</span> tf.train.NanLossDuringTrainingError
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> i % 100:
          <span class="org-keyword">print</span>(i, update)
      <span class="org-keyword">return</span> sess.run(opt)
</pre>
</div>
</div>

<div id="outline-container-orgda943b5" class="outline-3">
<h3 id="orgda943b5">Read the data</h3>
<div class="outline-text-3" id="text-orgda943b5">
<p>
Read the QC'ed data.
</p>

<p>
Onehot-encode the samples.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgb1779d3"><span class="org-variable-name">individuals</span> = <span class="org-builtin">sorted</span>(annotations[<span class="org-string">'chip_id'</span>].unique())
<span class="org-variable-name">onehot</span> = np.zeros((umi.shape[1], <span class="org-builtin">len</span>(individuals)), dtype=np.float32)
onehot[np.arange(onehot.shape[0]),annotations[<span class="org-string">'chip_id'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: individuals.index(x))] = 1
<span class="org-variable-name">onehot</span> = pd.DataFrame(onehot, columns=individuals, index=umi.columns)
onehot.shape
</pre>
</div>

<pre class="example">
(4995, 54)

</pre>

<p>
Check that one-hot encoding is OK:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">for</span> _ <span class="org-keyword">in</span> <span class="org-builtin">range</span>(100):
  <span class="org-variable-name">gene</span> = np.random.choice(umi.index)
  <span class="org-variable-name">ind</span> = np.random.choice(individuals)
  <span class="org-variable-name">idx</span> = individuals.index(ind)
  <span class="org-keyword">assert</span> (umi.loc[gene, (annotations[<span class="org-string">'chip_id'</span>] == ind).values] == 
          umi.loc[gene, onehot.dot(np.eye(onehot.shape[1])[idx]).astype(<span class="org-builtin">bool</span>)]).<span class="org-builtin">all</span>()
</pre>
</div>
</div>
</div>

<div id="outline-container-orga1dc686" class="outline-3">
<h3 id="orga1dc686">Fit NB</h3>
<div class="outline-text-3" id="text-orga1dc686">
<p>
Estimate means and dispersions assuming no dropout.
</p>

<div class="org-src-container">
<pre class="src src-ipython">&lt;&lt;zinb-imports&gt;&gt;
&lt;&lt;tf-imports&gt;&gt;
&lt;&lt;zinb-impl&gt;&gt;
&lt;&lt;read-data-qc&gt;&gt;
&lt;&lt;onehot-qc&gt;&gt;
<span class="org-variable-name">mean</span>, <span class="org-variable-name">dispersion</span> = fit(
  umi=umi.values.T.astype(np.float32),
  onehot=onehot.values.astype(np.float32),
  size_factor=umi.agg(np.<span class="org-builtin">sum</span>).astype(np.float32).values.reshape(-1, 1),
  learning_rate=1e-2,
  max_epochs=8000)
pd.DataFrame(mean.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/mean2.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
pd.DataFrame(dispersion.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/dispersion2.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb50c3a6" class="outline-3">
<h3 id="orgb50c3a6">Fit ZINB</h3>
<div class="outline-text-3" id="text-orgb50c3a6">
<p>
Estimate the parameters of the zero-inflated model assuming dropout per gene.
</p>

<div class="org-src-container">
<pre class="src src-ipython">&lt;&lt;zinb-imports&gt;&gt;
&lt;&lt;tf-imports&gt;&gt;
&lt;&lt;zinb-impl&gt;&gt;
&lt;&lt;read-data-qc&gt;&gt;
&lt;&lt;onehot-qc&gt;&gt;
<span class="org-variable-name">mean</span>, <span class="org-variable-name">dispersion</span>, <span class="org-variable-name">dropout</span> = fit(
  umi=umi.values.T.astype(np.float32),
  onehot=onehot.values.astype(np.float32),
  size_factor=umi.agg(np.<span class="org-builtin">sum</span>).astype(np.float32).values.reshape(-1, 1),
  gene_dropout=<span class="org-constant">True</span>,
  learning_rate=1e-2,
  max_epochs=8000)
pd.DataFrame(mean.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi-mean.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
pd.DataFrame(dispersion.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi-dispersion.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
pd.DataFrame(dropout.T, index=umi.index).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi-dropout.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf48a12b" class="outline-3">
<h3 id="orgf48a12b">Fit ZINB2</h3>
<div class="outline-text-3" id="text-orgf48a12b">
<p>
Estimate the parameters of the zero-inflated model assuming dropout per
individual and gene.
</p>

<div class="org-src-container">
<pre class="src src-ipython">&lt;&lt;zinb-imports&gt;&gt;
&lt;&lt;tf-imports&gt;&gt;
&lt;&lt;zinb-impl&gt;&gt;
&lt;&lt;read-data-qc&gt;&gt;
&lt;&lt;onehot-qc&gt;&gt;
<span class="org-variable-name">mean</span>, <span class="org-variable-name">dispersion</span>, <span class="org-variable-name">dropout</span> = fit(
  umi=umi.values.T.astype(np.float32),
  onehot=onehot.values.astype(np.float32),
  size_factor=umi.agg(np.<span class="org-builtin">sum</span>).astype(np.float32).values.reshape(-1, 1),
  gene_dropout=<span class="org-constant">True</span>,
  ind_dropout=<span class="org-constant">True</span>,
  learning_rate=1e-2,
  max_epochs=8000)
pd.DataFrame(mean.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi2-mean.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
pd.DataFrame(dispersion.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi2-dispersion.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
pd.DataFrame(dropout.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi2-dropout.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6ace9b3" class="outline-2">
<h2 id="org6ace9b3">numpy/scipy implementation</h2>
<div class="outline-text-2" id="text-org6ace9b3">
<p>
Optimize the negative log-likelihood.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="org9951dba"><span class="org-keyword">import</span> scipy.optimize <span class="org-keyword">as</span> so

<span class="org-keyword">def</span> <span class="org-function-name">log</span>(x):
  <span class="org-doc">"""Numerically safe log"""</span>
  <span class="org-keyword">return</span> np.log(x + 1e-8)

<span class="org-keyword">def</span> <span class="org-function-name">sigmoid</span>(x):
  <span class="org-doc">"""Numerically safe sigmoid"""</span>
  <span class="org-variable-name">lim</span> = np.log(np.finfo(np.float64).resolution)
  <span class="org-keyword">return</span> np.clip(sp.expit(x), lim, -lim)

<span class="org-keyword">def</span> <span class="org-function-name">zinb</span>(theta, x, size):
  <span class="org-variable-name">theta</span>, <span class="org-variable-name">dropout</span> = theta[:2], sigmoid(theta[2])
  <span class="org-variable-name">case_zero</span> = log(dropout + (1 - dropout) * np.exp(-nb(theta, x, size)))
  <span class="org-variable-name">case_non_zero</span> = log(1 - dropout) - nb(theta, x, size)
  <span class="org-keyword">return</span> -np.where(x &lt; 1e-8, case_zero, case_non_zero).mean()

<span class="org-keyword">def</span> <span class="org-function-name">nb</span>(theta, x, size):
  <span class="org-variable-name">mean</span>, <span class="org-variable-name">inv_disp</span> = np.exp(theta)
  <span class="org-variable-name">mean</span> *= size
  <span class="org-keyword">assert</span> mean.shape == x.shape
  <span class="org-keyword">return</span> -(x * log(mean / inv_disp) -
           x * log(1 + mean / inv_disp) -
           inv_disp * log(1 + mean / inv_disp) +
           sp.gammaln(x + inv_disp) -
           sp.gammaln(inv_disp) -
           sp.gammaln(x + 1)).mean()
</pre>
</div>

<p>
Write the data to the database. Use the pass through the count matrix to
compute and write out size factors for each cell.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">annotations</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-annotation.txt'</span>)
<span class="org-variable-name">keep_genes</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/genes-pass-filter.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">keep_samples</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/quality-single-cells.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">annotations</span> = annotations.loc[keep_samples.values.ravel()]
<span class="org-variable-name">annotations</span>[<span class="org-string">'sample'</span>] = annotation.<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: <span class="org-string">'{chip_id}.{experiment:08d}.{well}'</span>.<span class="org-builtin">format</span>(**<span class="org-builtin">dict</span>(x)), axis=1)
<span class="org-variable-name">annotations</span> = annotations.set_index(<span class="org-string">'sample'</span>)
<span class="org-variable-name">annotations</span>[<span class="org-string">'size'</span>] = np.zeros(annotations.shape[0])
<span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
  conn.execute(<span class="org-string">'drop table if exists umi;'</span>)
  <span class="org-keyword">for</span> chunk <span class="org-keyword">in</span> pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz'</span>, index_col=0, chunksize=100):
    <span class="org-variable-name">chunk</span> = (chunk
             .<span class="org-builtin">filter</span>(items=keep_genes[keep_genes.values.ravel()].index, axis=<span class="org-string">'index'</span>)
             .loc[:,keep_samples.values.ravel()])
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> chunk.empty:
      <span class="org-variable-name">annotations</span>[<span class="org-string">'size'</span>] += chunk.<span class="org-builtin">sum</span>(axis=0)
      chunk.reset_index().melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'sample'</span>).to_sql(name=<span class="org-string">'umi'</span>, con=conn, index=<span class="org-constant">False</span>, if_exists=<span class="org-string">'append'</span>)
  annotations[[<span class="org-string">'chip_id'</span>, <span class="org-string">'size'</span>]].to_sql(name=<span class="org-string">'annotation'</span>, con=conn, if_exists=<span class="org-string">'replace'</span>)
  conn.execute(<span class="org-string">'create index ix_umi on umi(gene, sample);'</span>)
</pre>
</div>

<p>
Use this to check the parameter estimation for a particular gene/individual.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">def</span> <span class="org-function-name">extract_data</span>(ind, gene):
  <span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
    <span class="org-variable-name">umi</span> = pd.read_sql(<span class="org-string">"""select umi.value, annotation.size from umi, annotation </span>
<span class="org-string">    where annotation.chip_id == ? and gene == ? and </span>
<span class="org-string">    umi.sample == annotation.sample;"""</span>, con=conn, params=(ind, gene))
    <span class="org-keyword">return</span> umi
</pre>
</div>

<p>
Shard the data to parallelize over nodes. Doing this in one pass over the
count matrix is easier than doing this in one pass over the database table
because we don't have to worry about accidentally splitting up data for an
individual/gene pair across chunks.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
  <span class="org-variable-name">annotation</span> = pd.read_sql(<span class="org-string">'select * from annotation'</span>, con=conn)

<span class="org-variable-name">keep_samples</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/quality-single-cells.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">keep_genes</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/genes-pass-filter.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">keep_genes</span> = keep_genes[keep_genes.values].index
<span class="org-variable-name">i</span> = 0
<span class="org-keyword">for</span> chunk <span class="org-keyword">in</span> pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz'</span>, index_col=0, chunksize=1000):
  <span class="org-keyword">print</span>(<span class="org-string">'Processing chunk {}'</span>.<span class="org-builtin">format</span>(i))
  <span class="org-variable-name">chunk</span> = (chunk
           .loc[:,keep_samples.values.ravel()]
           .<span class="org-builtin">filter</span>(items=keep_genes, axis=<span class="org-string">'index'</span>))
  <span class="org-keyword">if</span> <span class="org-keyword">not</span> chunk.empty:
    <span class="org-variable-name">chunk</span> = (chunk
             .reset_index()
             .melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'sample'</span>)
             .merge(annotation[[<span class="org-string">'chip_id'</span>, <span class="org-string">'sample'</span>, <span class="org-string">'size'</span>]], on=<span class="org-string">'sample'</span>)
             .sort_values([<span class="org-string">'gene'</span>, <span class="org-string">'chip_id'</span>, <span class="org-string">'sample'</span>]))
    chunk.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/density-estimation/chunk-{}.txt.gz'</span>.<span class="org-builtin">format</span>(i), columns=[<span class="org-string">'gene'</span>, <span class="org-string">'chip_id'</span>, <span class="org-string">'sample'</span>, <span class="org-string">'value'</span>, <span class="org-string">'size'</span>], compression=<span class="org-string">'gzip'</span>, sep=<span class="org-string">'\t'</span>)
    <span class="org-variable-name">i</span> += 1
</pre>
</div>

<p>
Process each chunk in parallel.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgbd92003"><span class="org-keyword">def</span> <span class="org-function-name">fit_gene</span>(chunk):
  <span class="org-variable-name">res0</span> = so.minimize(nb, x0=[0, 0], args=(chunk[:,0], chunk[:,1]))
  <span class="org-variable-name">pi0</span> = (chunk[:,0] == 0).<span class="org-builtin">sum</span>() / chunk.shape[0] + 1e-8
  <span class="org-variable-name">res</span> = so.minimize(zinb, x0=<span class="org-builtin">list</span>(res0.x) + [sp.logit(pi0 + 1e-8)], args=(chunk[:,0], chunk[:,1]))
  <span class="org-comment-delimiter"># </span><span class="org-comment">Log likelihood of ZINB vs. NB. We need to flip signs again</span>
  <span class="org-variable-name">llr</span> = chunk.shape[0] * (res0.fun - res.fun)
  <span class="org-keyword">return</span> <span class="org-builtin">list</span>(res0.x) + [res0.success] + <span class="org-builtin">list</span>(res.x) + [res.success, llr]

<span class="org-keyword">def</span> <span class="org-function-name">compute_breaks</span>(chunk, by_ind=<span class="org-constant">False</span>):
  <span class="org-comment-delimiter"># </span><span class="org-comment">Each subproblem has fixed size, so we can just split on integer indices</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">(instead of grouping)</span>
  <span class="org-variable-name">num_genes</span> = <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(chunk[<span class="org-string">'gene'</span>]))
  <span class="org-variable-name">num_samples</span> = <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(chunk[<span class="org-string">'sample'</span>]))
  <span class="org-variable-name">breaks</span> = num_samples * np.arange(num_genes).reshape(-1, 1)
  <span class="org-keyword">if</span> by_ind:
    <span class="org-variable-name">num_samples_per_ind</span> = chunk.iloc[:num_samples][<span class="org-string">'chip_id'</span>].value_counts().sort_index().values
    <span class="org-comment-delimiter"># </span><span class="org-comment">This can't be written += because of broadcasting</span>
    <span class="org-variable-name">breaks</span> = breaks + np.cumsum(num_samples_per_ind).reshape(1, -1)
  <span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">We need to get the right end point of each subproblem (exclusive)</span>
    <span class="org-variable-name">breaks</span> += num_samples
  <span class="org-keyword">return</span> breaks.ravel()
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">&lt;&lt;zinb-imports&gt;&gt;
<span class="org-keyword">import</span> argparse
<span class="org-keyword">import</span> gzip
<span class="org-keyword">import</span> os
<span class="org-keyword">import</span> multiprocessing <span class="org-keyword">as</span> mp
<span class="org-keyword">import</span> sqlite3
&lt;&lt;np-zinb-impl&gt;&gt;
&lt;&lt;process-chunk-impl&gt;&gt;

<span class="org-keyword">with</span> mp.Pool() <span class="org-keyword">as</span> pool:
  <span class="org-variable-name">chunk</span> = pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/density-estimation/chunk-{}.txt.gz'</span>.<span class="org-builtin">format</span>(os.getenv(<span class="org-string">'SLURM_ARRAY_TASK_ID'</span>)))
  <span class="org-variable-name">breaks</span> = compute_breaks(chunk, by_ind=<span class="org-constant">True</span>)
  <span class="org-variable-name">res</span> = pool.<span class="org-builtin">map</span>(fit_gene, np.split(chunk[[<span class="org-string">'value'</span>, <span class="org-string">'size'</span>]].values, breaks[:-1]))

<span class="org-keyword">with</span> gzip.<span class="org-builtin">open</span>(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/density-estimation/result-{}.txt.gz'</span>.<span class="org-builtin">format</span>(os.getenv(<span class="org-string">'SLURM_ARRAY_TASK_ID'</span>)), <span class="org-string">'wt'</span>) <span class="org-keyword">as</span> f:
  <span class="org-keyword">for</span> b <span class="org-keyword">in</span> breaks:
    <span class="org-variable-name">gene</span>, <span class="org-variable-name">ind</span> = chunk.iloc[b - 1][[<span class="org-string">'gene'</span>, <span class="org-string">'chip_id'</span>]]
    <span class="org-keyword">print</span>(gene, ind, *res.pop(0), <span class="org-builtin">file</span>=f)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">sbatch --partition=broadwl --job-name=<span class="org-string">"np-zinb"</span> --mem=4G -a 0-20 -n1 -c28 --exclusive
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
<span class="org-builtin">source</span> activate scqtl
python /scratch/midway2/aksarkar/singlecell/np-zinb.py
</pre>
</div>

<p>
Populate the database.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
  conn.execute(<span class="org-string">'drop table if exists params;'</span>)
  <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(20):
    <span class="org-keyword">for</span> chunk <span class="org-keyword">in</span> pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/density-estimation/result-{}.txt.gz'</span>.<span class="org-builtin">format</span>(i), sep=<span class="org-string">' '</span>, header=<span class="org-constant">None</span>, chunksize=1000):
      <span class="org-variable-name">chunk.columns</span> = [<span class="org-string">'gene'</span>, <span class="org-string">'ind'</span>, <span class="org-string">'nb_log_mean'</span>, <span class="org-string">'nb_log_disp'</span>, <span class="org-string">'nb_success'</span>, <span class="org-string">'zinb2_log_mean'</span>, <span class="org-string">'zinb2_log_disp'</span>, <span class="org-string">'zinb2_logodds'</span>, <span class="org-string">'zinb_success'</span>, <span class="org-string">'llr'</span>]
      chunk.to_sql(name=<span class="org-string">'params'</span>, con=conn, index=<span class="org-constant">False</span>, if_exists=<span class="org-string">'append'</span>)
  conn.execute(<span class="org-string">'create index ix_params on params(gene, ind);'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgebc1920" class="outline-2">
<h2 id="orgebc1920">Genome-wide distribution of dispersion</h2>
<div class="outline-text-2" id="text-orgebc1920">
<p>
The index of dispersion for observed data \(r_{ijk}\) at gene \(k\) is:
</p>

<p>
\[ D_k = \frac{V[r_{ijk}]}{E[r_{ijk}]} \]
</p>

<p>
The numerator can be decomposed according to the law of total variance:
</p>

<p>
\[ V[r_{ijk}] = V_i[E_j[r_{ijk}]] + E_i[V_j[r_{ijk}]] \]
</p>

<p>
\[ = V_i[\mu_{ik}] + E_i[\mu_{ik} + \mu_{ik}^2 \phi_{ik}] \]
</p>

<p>
The first term is the variation between individual means, and the second term
is variation within each individual.
</p>

<p>
Similarly, the denominator can be decomposed according to the law of total
expectation:
</p>

<p>
\[ E[r_{ijk}] = E_i[E_j[r_{ijk}]] = E_i[\mu_{ik}] \]
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
  <span class="org-variable-name">params</span> = (pd.read_sql(
    <span class="org-string">"""select gene, ind, case when llr &lt; 1 then nb_log_mean else zinb2_log_mean end</span>
<span class="org-string">    as log_mean, case when llr &lt; 1 then nb_log_disp else zinb2_log_disp end as</span>
<span class="org-string">    log_disp, case when llr &lt; 1 then null else zinb2_logodds end as logodds from</span>
<span class="org-string">    params where ind != "NA18498";"""</span>, conn))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">params</span>[<span class="org-string">'var'</span>] = np.exp(params[<span class="org-string">'log_mean'</span>]) + np.exp(2 * params[<span class="org-string">'log_mean'</span>] + params[<span class="org-string">'log_disp'</span>])
<span class="org-variable-name">total_var</span> = params.groupby(<span class="org-string">'gene'</span>).<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: np.exp(x[<span class="org-string">'log_mean'</span>]).var() + x[<span class="org-string">'var'</span>].mean())
<span class="org-variable-name">total_exp</span> = params.groupby(<span class="org-string">'gene'</span>).<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: np.exp(x[<span class="org-string">'log_mean'</span>]).mean())
<span class="org-variable-name">dispersion</span> = total_var / total_exp
</pre>
</div>

<p>
Plot the distribution of dispersions.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.hist(np.log(dispersion[np.isfinite(dispersion)]), bins=100, color=<span class="org-string">'k'</span>)
plt.xlabel(<span class="org-string">'Log-transformed index of dispersion'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Number of genes'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/zinb.org/global-dispersion-hist.png" alt="global-dispersion-hist.png">
</p>
</div>

<p>
Write out the computed dispersions.
</p>

<div class="org-src-container">
<pre class="src src-ipython">dispersion[np.isfinite(dispersion)].to_frame().to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/index-dispersion-by-gene.txt.gz'</span>, compression=<span class="org-string">'gzip'</span>, header=<span class="org-constant">False</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abhishek Sarkar</p>
<p class="date">Created: 2018-03-16 Fri 12:51</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
